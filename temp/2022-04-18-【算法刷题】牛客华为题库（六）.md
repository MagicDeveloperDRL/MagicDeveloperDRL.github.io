---

layout:     post
title:      「算法刷题」牛客华为题库（六）
subtitle:   C++11
date:       2022-04-18
author:     MRL Liu
header-img: img/post-bg-hacker.png
catalog: true
tags:
    - 算法刷题
---

[TOC]

​		华为机试题库共103道题目，其中入门级5道，简单级46道，中等级36道，较难级13道，困难级3道。计划在7天内共完成入门级，简单级，中等级的共计87道题目，则每天应当完成13道左右。计划每天完成：

​			入门级：1道    简单级：7道      中等级：6道        

# 一、简单级

## 1、**HJ

```c++
#include <bits/stdc++.h>
using namespace std;
int main(){
    // 获取输入
    int n;
    cin>>n;
    int res=0;
    while(n){
        if(n%2==1) res++;
        n=n/2;
    }
    cout<<res;
}
```

## 2、**HJ

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    int n;
    while(cin>>n){
        int res=0;
        while(n){
            if(n%2==1) res++;
            n=n/2;
        }
        cout<<res<<endl;
    }
    return 0;
}
```

## 3、**HJ

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    int n;
    cin>>n;
    //转换为二进制
    string s;// 该数字的二进制格式
    while(n){
        s=to_string(n%2)+s;
        n=n/2;
    }
    // 记录该二进制下的连续1的个数
    int res=0;
    for(int i=0;i<s.length();++i){
        // 从i出发，计算连续1的个数tmp
        int tmp =0;    //计数器，存放临时变量
        while(i<s.length()&&s[i]=='1'){
            tmp++;
            i++;
        }
        // 保存历史最大值
        res=max(res,tmp);
    }
    cout<<res;
}
```

## 4、**HJ

```C++
#include<bits/stdc++.h>
using namespace std;
int main(){
    // 获取输入
    int n,tmp;
    cin>>n;
    int num_1=0;// 正数个数
    int num_2=0;// 负数个数
    double sum=0.0;
    while(n--){
        cin>>tmp;
        if(tmp>0) {
            sum+=tmp;
            num_1++;
        }
        else if(tmp<0)num_2++;
    }
    double mean=0.0;
    if(num_1!=0) mean=sum/num_1;
    printf("%d %.1f\n",num_2,mean);
    return 0;
}
```

## 5、**HJ

```c++
#include<bits/stdc++.h>
using namespace std;
/*这道题不需要实现表格功能，只要满足对应的输入输出即可*/
int main(){
    int m,n;    //数据表的行数和列数
    while(cin>>m>>n) {    //输入数据表的行数和列数
        // 初始化表格
        if(m>9 || n>9)    //如果行数或者列数大于9，返回-1，否则返回0
            cout<<-1<<endl;
        else
            cout<<0<<endl;
        // 交换2个坐标
        int x1,y1,x2,y2;    //(x1,y1)(x2,y2)为两个坐标
        cin>>x1>>y1>>x2>>y2;    //分别输入x1,y1,x2,y2的值
        if(x1>=m || y1>=n || x2>=m || y2>=n)    //如果行坐标的值大于等于数据表的行数；或者列坐标的值大于等于数据表的列数，那么返回-1，否则返回0
            cout<<-1<<endl;
        else
            cout<<0<<endl;
        // 在row上添加一行
        int row;    //row为行号
        cin>>row;    //输入行号
        if(row<0 && row>=m || m==9)    //如果行号大于数据表的行数，或者数据表的行数为9，则返回-1，否则返回0
            cout<<-1<<endl;
        else
            cout<<0<<endl;
        // 在column左边添加一列
        int column;    //row为列号
        cin>>column;    //输入列号
        if(column<0 || column>=n || n==9)    //如果列号大于数据表的列数，或者数据表的列数为9，则返回-1，否则返回0
            cout<<-1<<endl;
        else
            cout<<0<<endl;
        // 查询x和y的坐标值
        int x,y;    //(x,y)为坐标
        cin>>x>>y;    //输入x和y的值
        if(x<0 || x>=m || y<0 || y>=n)    //如果行坐标的值大于等于数据表的行数；或者列坐标的值大于等于数据表的列数，那么返回-1，否则返回0
            cout<<-1<<endl;
        else
            cout<<0<<endl;
    }
    return 0;
}
```

## 6、**HJ

```C++
#include<bits/stdc++.h>
using namespace std;

int getSum(int n,int& sum){
    int res=0;
    if(n==1) res=2;
    else res+=getSum(n-1,sum)+3;
    sum+=res;
    return res;
}

int main(){
    // 获取输入
    int n;
    cin>>n;
    // 递归调用
    int sum=0;
    getSum(n,sum);
    cout<<sum;
}
```

## 7、**HJ

```C++
#include<bits/stdc++.h>
using namespace std;
/*
求自守数的解题思路
规律：个位数为 0、1、5、6 的数才可能是自守数，故采用筛选法，只判断符合该条件的数
思路1：可以把整数（数及其平方）转换为字符串，通过比较长字符串的末尾是否与短字符串相同即可
如：25 * 25 = 625，字符串'625'的末尾'25'与字符串'25'的相同
思路2：若该数的平方与该数的差，去模该数对应的各个进制位均等于零，则该数为自守数
如：25 * 25 = 625，625 - 25 = 600，600 % (10*1) = 0，600 % （10 * 2） = 0
*/
int main(){
    // 获取输入
    int n;
    cin>>n;
    // 递归调用
    int res=0;
    for(int i=0;i<=n;++i){
        //仅对个位数符合条件的数执行自守数的判断(没有该判断也能通过，加上效率更高)
        if((i%10 == 0) || (i%10 == 1) || (i%10 == 5) || (i%10 == 6)){
            long j = i*i;
            string s1=to_string(i);
            string s2=to_string(j);
            int n1=s1.length();
            int n2=s2.length();
            if(s2.substr(n2-n1,n1)==s1) res++;
        }
    }
    cout<<res;
}
```

# 二、中等级

## 1、**HJ

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    string s;
    getline(cin,s);
    int N;
    cin>>N;
    // 处理
    int len=s.length();
    string sub;
    string res;
    int maxgc=0;
    // 遍历字符串
    for(int i=0;i<=len-N;++i){
        sub=s.substr(i,N);//获取从索引i开始的N长度的子串
        int gc=0;
        // 统计该子串中GC个数
        for(char c:sub){
            if(c=='G'||c=='C')
                gc++;
        }
        // 如果是最大则记录
        if(gc>maxgc){
            res=sub;
            maxgc=gc;
        }
    }
    cout<<res;
    return 0;
}
```

## 2、**HJ

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    string s1;
    string s2;
    getline(cin,s1);
    getline(cin,s2);
    // 处理
    int i=s1.length()-1;
    int j=s2.length()-1;
    string res;
    bool carry=false;
    int sum=0;
    // 同时遍历两个字符串
    while(i>=0&&j>=0){
        sum=0;
        int n1=s1[i--]-'0';
        int n2=s2[j--]-'0';
        sum=n1+n2;
        if(carry) sum++;
        res=to_string(sum%10)+res;
        if(sum>=10) carry=true;
        else carry=false;
    }
    while(i>=0){
        int sum=s1[i--]-'0';
        if(carry) sum++;
        res=to_string(sum%10)+res;
        if(sum>=10) carry=true;
        else carry=false;
    }
    while(j>=0){
        int sum=s2[j--]-'0';
        if(carry) sum++;
        res=to_string(sum%10)+res;
        if(sum>=10) carry=true;
        else carry=false;
    }
    if(carry) res="1"+res;
    cout<<res;
    return 0;
}
```

## 3、**HJ

```C++
#include<bits/stdc++.h>
#include<sstream>
using namespace std;

int main(){
    string input;
    vector<pair<string, string>> instru = {{"reset",""},
                                           {"reset","board"},
                                           {"board","add"},
                                           {"board","delete"},
                                           {"reboot","backplane"},
                                           {"backplane","abort"}};    //存放每一对关键字
    vector<string> outInstru = {"reset what","board fault","where to add",
                               "no board at all","impossible","install first"};    //存放每条命令对应执行结果
    while(getline(cin, input)) {    //获取输入的一行字符串
        stringstream ss(input);    //通过stingstream和getline的组合实现对字符串按空格进行分割
        string key1,key2;
        getline(ss, key1, ' ');
        getline(ss, key2, ' ');
        int count=0;    //记录匹配的关键字个数
        string result;    //存放执行结果
        for(auto it=instru.begin();it!=instru.end();it++) {//对所有命令进行匹配
            int i1=it->first.find(key1);//i1记录key1在命令的前半部分第一次出现的下标
            int i2;    //i2记录key2在命令的后半部分第一次出现的下标
            if(key2!="") {    //如果key2不为空字符串，则获取key2在命令的后半部分第一次出现的下标
                i2=it->second.find(key2);
            }else if(key2==""&&it->second.empty()) {    //如果key2和命令的后半部分都为空字符串，则i2为0
                i2=0;
            }else{    //否则i2为-1，表示后半部分没有匹配到对应的命令
                i2=-1;
            }
            if(i1==0 && i2==0) {    //只有当i1和i2都匹配成功时，才对匹配成功的命令进行计数
                count++;
                result = outInstru[it-instru.begin()];    //result存放执行结果
            }
        }
        if(count==1) {    //如果只有一个匹配的关键字，标志匹配命令成功，输出对应执行结果
            cout<<result<<endl;
        }else{    //否则就是没有匹配成功，输出"unknown command"
            cout<<"unknown command"<<endl;
        }
    }
    return 0;
}
```

## 4、**HJ

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    string s;
    getline(cin,s);
    // 遍历字符串，如果存在""，则将其中的空格改为*
    bool flag=false;
    for(int i=0;i<s.length();++i){
        // 如果此时遇到了左引号
        if(!flag&&s[i]=='"')flag=true;
        // 如果此时遇到了右引号
        else if(flag&&s[i]=='"')flag=false;
        //如果左引号已经遇到过
        if(flag&&s[i]==' ')s[i]='*';
    }
    // 转换为字符流，切分空格
    stringstream ss(s);
    string t;
    vector<string> arr;
    while(getline(ss,t,' ')){
        arr.push_back(t);
    }
    cout<<arr.size()<<endl;
    // 输出结果
    for(string t:arr){
        // 如果遇到了"，则将其中的*切换为空格
        if(t[0]=='"'){
            string res=t.substr(1,t.length()-2);
            for(char c:res){
                if(c=='*') cout<<' ';
                else cout<<c;
            }
            cout<<endl;
        } 
        else cout<<t<<endl;
    }
    return 0;
}
```

## 5、**HJ

```C++
#include<bits/stdc++.h>
using namespace std;
// 递归调用：匹配当前一个字符s是被匹配的，p是匹配的
bool match(const char* s,const char* p)
{
    // 终止条件
    if((*p=='\0')&&(*s=='\0'))return true;// 如果两个同时到达末尾，则匹配
    if((*p=='\0')||(*s=='\0'))return false;// 如果两个只有一个达到末尾，则不匹配
    // 如果当前字符是？
    if(*p=='?')
    {
        if(!isdigit(*s)&&!isalpha(*s)) return false;// 如果s不是英文字母和数字，则不匹配
        return match(s+1,p+1);// 匹配下一个字符
    }
    // 如果当前字符是*
    else if(*p=='*')
    {
        while(*p=='*')p++;//检查p后面是否存在*,如果存在继续右移
        p--;//p左移，此时p指向连续*中的最后一个*
        //匹配0个，匹配1个，匹配多个/-1个，直至1个
        return match(s,p+1) || match(s+1,p+1) || match(s+1,p);
    }
    // 如果当前字符的大小写匹配，则继续匹配下一个字符
    else if(tolower(*p)==tolower(*s))
        return match(s+1,p+1);// 匹配下一个字符
    return false;
}

int main(){ 
    string p,s;
    while(cin>>p>>s){
        bool res = match(s.c_str(),p.c_str());
        if(res)cout<<"true"<<endl;
        else cout<<"false"<<endl;
    }
    return 0;
}
```

## 6、**HJ

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    double h;
    cin>>h;
    // 计算结果
    double dis=0;// 必须初始化，否则结果为nan
    for(int i=0;i<5;++i){
        dis+=h;//落地的长度
        h/=2; // 上升的长度
        if(i==4){
            printf("%.6f\n%.6f",dis,h);
        }
        dis+=h;// 加上弹上的长度
    }
    return 0;
}
```



