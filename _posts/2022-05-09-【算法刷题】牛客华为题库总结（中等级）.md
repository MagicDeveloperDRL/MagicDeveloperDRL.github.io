---

layout:     post
title:      「算法刷题」牛客华为题库总结（中等级）
subtitle:   C++11
date:       2022-05-09
author:     MRL Liu
header-img: img/post-bg-hacker.png
catalog: true
tags:
    - 算法刷题
---

[TOC]

​		华为机试题库共103道题目，其中入门级5道，简单级46道，中等级36道，较难级13道，困难级3道。计划在7天内共完成入门级，简单级，中等级的共计87道题目，则每天应当完成13道左右。计划每天完成：

​			入门级：1道    简单级：7道      中等级：6道        

# 一、基础数学篇（12）



# 二、哈希篇（10）

## 1、**HJ41** **称砝码**

```C++
#include<iostream>
#include<string>
#include<vector>
#include<set>
using namespace std;
/*
    思路：将所有的砝码按照数量加入一个数组v中
    初始化一个set，其中只有一个0
    遍历数组v中的所有砝码，每取出一个砝码v[i]，就向set插入原先set中的所有元素+v[i]
*/
int main(){
    // 读取输入
    int n;
    cin>>n;
    int a[10];
    for(int i = 0; i < n; i++) cin >> a[i];//记录数量
    int tmp;
    vector<int> v;
    for(int i = 0; i < n; i++)
    {
        cin >> tmp;
        for(int j = 0; j < tmp; j++) v.push_back(a[i]);//将所有的砝码按数量加入
    }
    
    set<int> s;
    s.insert(0);
    for(int i = 0; i < v.size(); i++)
    {
        set<int> t(s);
        // 遍历集合
        for(auto it = t.begin(); it != t.end(); it ++)
        {
            s.insert(*it + v[i]);
        }
    }
    cout << s.size() << endl;
    return 0;
}
```

## 2、**HJ59** **找出字符串中第一个只出现一次的字符**

```C++
#include<iostream>
#include<string>
#include <unordered_map> 
using namespace std;

int main(){
    // 读取输入
    string s;
    getline(cin,s);
    // 统计所有字符的频率
    unordered_map<char,int> dict;
    for(char c:s){
        dict[c]++;
    }
    // 遍历s，查找第一个只出现一次的字符
    char res='1';
    for(char c:s){
        if(dict[c]==1){
            res=c;
            break;
        }
    }
    if(res=='1') cout<<"-1";
    else cout<<res;
    return 0;
}
```

# 、数组篇（8 ）

## 、**HJ33** **整数与IP地址间的转换**

```C++
#include<iostream>
using namespace std;

int main(){
    long long int a,b,c,d;
    long long int num;
    // 格式化输入
    while(scanf("%lld.%lld.%lld.%lld",&a,&b,&c,&d)!=EOF){
        cin>>num;// 获取数字，左移24位，乘
        cout<<(a<<24)+(b<<16)+(c<<8)+d<<endl;//输出IP地址
        //获取A，
        a = num>>24;
        //获取B
        num = num-(a<<24);
        b = num>>16;
        //获取C
        num = num-(b<<16);
        c = num>>8;
         //获取D
        d = num-(c<<8);
        printf("%lld.%lld.%lld.%lld",a,b,c,d);
    }
    return 0;
}
```





# 四、字符串篇（13）

## 1、**HJ17** 坐标移动

```C++
#include<iostream>
#include<string>
#include <sstream>// 字符串流
#include <regex> // 正则表达式
using namespace std;

int main(){
    // 读取输入
    string s;
    getline(cin,s);
    // 处理字符串
    pair<int,int> res(0,0);// 二维坐标
    string t;
    stringstream ss(s);//将字符串转换为字符串流
    while(getline(ss,t,';')) {
        if(t.empty()) continue;
        string subStr = t.substr(1);//获取第一个字符之后的子串
        // 如果子串是数字形式
        if(regex_match(subStr,regex("[0-9]{0,}"))) {
            switch(t[0]) {
                case 'A': res.first -= stoi(subStr); break; //左移
                case 'D': res.first += stoi(subStr); break; //右移
                case 'W': res.second += stoi(subStr); break; //上移
                case 'S': res.second -= stoi(subStr); break; //下移
                default: break; //无效
            }          
        }
    }
    cout << res.first << "," << res.second << endl;
    return 0;
}
```

## 2、**HJ20** **密码验证合格程序**

```C++
#include<iostream>
#include<string>
#include <unordered_set> 
using namespace std;
bool is_password(string s){
    int len = s.size();
    // 要求1： 长度大于8
    if (len <= 8) return false;
    // 要求2：至少包含3种字符
    unordered_set<int> set;
    for (int i = 0; i < len; ++i) {
        // 包含A-Z
        if (s[i] >= 'A' && s[i] <= 'Z')
            set.insert(1);
        // 包含a-z
        else if (s[i] >= 'a' && s[i] <= 'z')
            set.insert(2);
        // 包含0-9
        else if (s[i] >= '0' && s[i] <= '9')
            set.insert(3);
        else
            set.insert(4);
    }
    if (set.size() < 3) return false;
    // 要求3：不能有长度大于2的不含公共元素的子串重复 
    for (int i = 0; i < len - 3; ++i) {
        for (int j = i + 3; j < len - 3; ++j) {
            if (s.substr(i, 3) == s.substr(j, 3)) {
                return false; 
            }
        }
    }
    return true; 
}
int main(){
    // 读取输入
    string s;
    while(cin>>s){
        bool flag = is_password(s);
        if (flag) cout<<"OK";
        else cout<<"NG";
    }
    return 0;
}
```

## 3、**HJ26** **字符串排序**

```C++
#include<iostream>
#include<string>
#include <vector>
using namespace std;
/*
    思路：首先遍历26轮字符串，每次提取其中的一个字母到数组中
    然后再次遍历字符串，将其中的字母全部替换掉
*/
int main(){
    // 读取输入
    string str;
    getline(cin,str);
    int len = str.size(); //获取字符串长度
    vector <char> vec; //用一个 char 型的向量存储按规则排序后的字符串中的字母字符
    //规则一：英文字母从 A 到 Z 排列，不区分大小写。
    //规则二：同一个英文字母的大小写同时存在时，按照输入顺序排列。
    for (int j = 0; j < 26; j++)
    {
        // 遍历整个数组，每次遍历只取其中的一个英文字母
        for (int i = 0; i < len; i++)
        {
            if ((str[i] - 'a' == j) || (str[i] - 'A' == j))
            {
                vec.push_back(str[i]); //将符合规则的字母字符先后写入向量
            }
        }
    }
    //规则三：非英文字母的其它字符保持原来的位置。
    // 同时遍历字符串和vec
    for(int i = 0,k = 0;(i < len) && (k < vec.size()); i++)
    {
        // 如果当前字符是英文字母，就用vec[k]覆盖，否则跳过
        if((str[i] >= 'a' && str[i] <= 'z') || (str[i] >= 'A' && str[i] <= 'Z'))
        {
            str[i] = vec[k];
            k++;
        }
    }
    cout<<str;
    return 0;
}
```

## 4、**HJ27** **查找兄弟单词**

```C++
#include<iostream>
#include<string>
#include<vector>
#include<algorithm>
#include<unordered_map>
using namespace std;

bool is_brother(string &s,string &x){
    if(s==x) return false;
    unordered_map<char,int> dict;
    for(char c:s) dict[c]++;
    for(char c:x) dict[c]--;
    for(auto pair:dict){
        if(pair.second!=0) return false;
    }
    return true;
}

int main(){
    // 读取输入
    int n;
    int k;
    cin>>n;
    string s;
    vector<string> arr;
    vector<string> broArr;
    while(n--){
        cin>>s;
        arr.push_back(s);
    }
    string x;
    cin>>x;
    cin>>k;
    // 查找兄弟单词
    for(string str:arr){
        if(!is_brother(str,x))continue;
        broArr.push_back(str);
    }
    // 输出结果
    cout<<broArr.size()<<endl;
    if(k<=broArr.size()){
        sort(broArr.begin(),broArr.end());//排序
        cout<<broArr[k-1]<<endl;
    }
    return 0;
}
```

## 5、**HJ29** **字符串加解密**

```C++
#include<iostream>
#include<string>
#include <sstream>// 字符串流
#include <regex> // 正则表达式
using namespace std;

char encode(char c){
    if(c=='z')c='A';
    else if(c=='Z')c='a';
    else if(c=='9')c='0';
    else if(c>='a'&&c<'z'){
        c=c-'a'+1+'A';
    }
    else if(c>='A'&&c<'Z'){
        c=c-'A'+1+'a';
    }
    else if(c>='0'&&c<'9'){
        c=c-'0'+1+'0';
    }
    return c;
}
char decode(char c){
    if(c=='A')c='z';
    else if(c=='a')c='Z';
    else if(c=='0')c='9';
    else if(c>'a'&&c<='z'){
        c=c-'a'-1+'A';
    }
    else if(c>'A'&&c<='Z'){
        c=c-'A'-1+'a';
    }
    else if(c>'0'&&c<='9'){
        c=c-'0'-1+'0';
    }
    return c;
}

int main(){
    // 读取输入
    string s1;
    string s2;
    getline(cin,s1);
    getline(cin,s2);
    // 处理字符串
    for(int i=0;i<s1.length();++i) s1[i]=encode(s1[i]);
    for(int i=0;i<s2.length();++i) s2[i]=decode(s2[i]);
    cout<<s1<<endl;
    cout<<s2<<endl;
    return 0;
}
```

## 6、**HJ36** **字符串加密**

```C++
#include<iostream>
#include<string>
#include<map>
using namespace std;

string getKeyTab(string& key,string& tab){
    string m_key;
    // 去除key中的重复字母
    for(int i=0;i<key.size();i++){
        if(m_key.find(key[i])==-1)
            m_key.append(string(1,key[i]));
    }
    // 添加新字母
    char a='a';
    for(int i=m_key.size();m_key.size()<26;i++){
        if(m_key.find(a)==-1){
            m_key.append(string(1,a));
        }
        a++;
    }
    return m_key;
}


int main(){
    // 读取输入
    string key;
    string s;
    getline(cin,key);
    getline(cin,s);
    string tab="abcdefghijklmnopqrst";
    
    // 处理字符串
    string keytab=getKeyTab(key,tab);
    for(int i=0;i<s.size();++i){
        s[i]=keytab[s[i]-'a'];
    }
    cout<<s;
    return 0;
}
```

## 1、**HJ63** **DNA序列**

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    string s;
    getline(cin,s);
    int N;
    cin>>N;
    // 处理
    int len=s.length();
    string sub;
    string res;
    int maxgc=0;
    // 遍历字符串
    for(int i=0;i<=len-N;++i){
        sub=s.substr(i,N);//获取从索引i开始的N长度的子串
        int gc=0;
        // 统计该子串中GC个数
        for(char c:sub){
            if(c=='G'||c=='C')
                gc++;
        }
        // 如果是最大则记录
        if(gc>maxgc){
            res=sub;
            maxgc=gc;
        }
    }
    cout<<res;
    return 0;
}
```

## 2、**HJ57** **高精度整数加法**

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    string s1;
    string s2;
    getline(cin,s1);
    getline(cin,s2);
    // 处理
    int i=s1.length()-1;
    int j=s2.length()-1;
    string res;
    bool carry=false;
    int sum=0;
    // 同时遍历两个字符串
    while(i>=0&&j>=0){
        sum=0;
        int n1=s1[i--]-'0';
        int n2=s2[j--]-'0';
        sum=n1+n2;
        if(carry) sum++;
        res=to_string(sum%10)+res;
        if(sum>=10) carry=true;
        else carry=false;
    }
    while(i>=0){
        int sum=s1[i--]-'0';
        if(carry) sum++;
        res=to_string(sum%10)+res;
        if(sum>=10) carry=true;
        else carry=false;
    }
    while(j>=0){
        int sum=s2[j--]-'0';
        if(carry) sum++;
        res=to_string(sum%10)+res;
        if(sum>=10) carry=true;
        else carry=false;
    }
    if(carry) res="1"+res;
    cout<<res;
    return 0;
}
```

## 3、**HJ66** **配置文件恢复**

```C++
#include<bits/stdc++.h>
#include<sstream>
using namespace std;

int main(){
    string input;
    vector<pair<string, string>> instru = {{"reset",""},
                                           {"reset","board"},
                                           {"board","add"},
                                           {"board","delete"},
                                           {"reboot","backplane"},
                                           {"backplane","abort"}};    //存放每一对关键字
    vector<string> outInstru = {"reset what","board fault","where to add",
                               "no board at all","impossible","install first"};    //存放每条命令对应执行结果
    while(getline(cin, input)) {    //获取输入的一行字符串
        stringstream ss(input);    //通过stingstream和getline的组合实现对字符串按空格进行分割
        string key1,key2;
        getline(ss, key1, ' ');
        getline(ss, key2, ' ');
        int count=0;    //记录匹配的关键字个数
        string result;    //存放执行结果
        for(auto it=instru.begin();it!=instru.end();it++) {//对所有命令进行匹配
            int i1=it->first.find(key1);//i1记录key1在命令的前半部分第一次出现的下标
            int i2;    //i2记录key2在命令的后半部分第一次出现的下标
            if(key2!="") {    //如果key2不为空字符串，则获取key2在命令的后半部分第一次出现的下标
                i2=it->second.find(key2);
            }else if(key2==""&&it->second.empty()) {    //如果key2和命令的后半部分都为空字符串，则i2为0
                i2=0;
            }else{    //否则i2为-1，表示后半部分没有匹配到对应的命令
                i2=-1;
            }
            if(i1==0 && i2==0) {    //只有当i1和i2都匹配成功时，才对匹配成功的命令进行计数
                count++;
                result = outInstru[it-instru.begin()];    //result存放执行结果
            }
        }
        if(count==1) {    //如果只有一个匹配的关键字，标志匹配命令成功，输出对应执行结果
            cout<<result<<endl;
        }else{    //否则就是没有匹配成功，输出"unknown command"
            cout<<"unknown command"<<endl;
        }
    }
    return 0;
}
```

## 4、**HJ74** **参数解析**

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    string s;
    getline(cin,s);
    // 遍历字符串，如果存在""，则将其中的空格改为*
    bool flag=false;
    for(int i=0;i<s.length();++i){
        // 如果此时遇到了左引号
        if(!flag&&s[i]=='"')flag=true;
        // 如果此时遇到了右引号
        else if(flag&&s[i]=='"')flag=false;
        //如果左引号已经遇到过
        if(flag&&s[i]==' ')s[i]='*';
    }
    // 转换为字符流，切分空格
    stringstream ss(s);
    string t;
    vector<string> arr;
    while(getline(ss,t,' ')){
        arr.push_back(t);
    }
    cout<<arr.size()<<endl;
    // 输出结果
    for(string t:arr){
        // 如果遇到了"，则将其中的*切换为空格
        if(t[0]=='"'){
            string res=t.substr(1,t.length()-2);
            for(char c:res){
                if(c=='*') cout<<' ';
                else cout<<c;
            }
            cout<<endl;
        } 
        else cout<<t<<endl;
    }
    return 0;
}
```

# 

## 1、**HJ51** **输出单向链表中倒数第k个结点**

```C++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

struct ListNode
{
    int m_nKey;
    ListNode* m_pNext;
    ListNode(int val){m_nKey=val;m_pNext=nullptr;}
};


int main(){
    // 获取输入
    int n;
    ListNode* myCode= new ListNode(0);
    while(cin>>n){
        int tmp=0;
        ListNode* p=myCode;// 非常重要，遍历指针法
        while(n--){
            cin>>tmp;
            //创建单链表
            ListNode* newCode= new ListNode(tmp);
            p->m_pNext=newCode;
            p=p->m_pNext;
        }
        // 获取k
        cin>>tmp;
        ListNode* left=myCode->m_pNext;
        ListNode* right=myCode->m_pNext;
        while(tmp--) {
            right=right->m_pNext;
        }
        while(right){
            left=left->m_pNext;
            right=right->m_pNext;
        }
        cout<<left->m_nKey<<endl;
    }
}
```

# 六、递归篇（2）

## 5、**HJ71** **字符串通配符**

```C++
#include<bits/stdc++.h>
using namespace std;
// 递归调用：匹配当前一个字符s是被匹配的，p是匹配的
bool match(const char* s,const char* p)
{
    // 终止条件
    if((*p=='\0')&&(*s=='\0'))return true;// 如果两个同时到达末尾，则匹配
    if((*p=='\0')||(*s=='\0'))return false;// 如果两个只有一个达到末尾，则不匹配
    // 如果当前字符是？
    if(*p=='?')
    {
        if(!isdigit(*s)&&!isalpha(*s)) return false;// 如果s不是英文字母和数字，则不匹配
        return match(s+1,p+1);// 匹配下一个字符
    }
    // 如果当前字符是*
    else if(*p=='*')
    {
        while(*p=='*')p++;//检查p后面是否存在*,如果存在继续右移
        p--;//p左移，此时p指向连续*中的最后一个*
        //匹配0个，匹配1个，匹配多个/-1个，直至1个
        return match(s,p+1) || match(s+1,p+1) || match(s+1,p);
    }
    // 如果当前字符的大小写匹配，则继续匹配下一个字符
    else if(tolower(*p)==tolower(*s))
        return match(s+1,p+1);// 匹配下一个字符
    return false;
}

int main(){ 
    string p,s;
    while(cin>>p>>s){
        bool res = match(s.c_str(),p.c_str());
        if(res)cout<<"true"<<endl;
        else cout<<"false"<<endl;
    }
    return 0;
}
```

## 3、**HJ77** **火车进站**

```C++
#include<bits/stdc++.h>
using namespace std;

// in表示已经处理的火车数组，index表示火车序号，stk表示车站
void dfs(const vector<int>& in, int index, stack<int>& stk,vector<int> &path,vector<vector<int>> &res)
{
    // 当所有火车已经出站
    if (path.size() == in.size()) {
        res.push_back(path);// 添加结果
        return;
    }
    // 当前火车数组中面临的2种选择：当前火车进站或者上一个火车出站
    // 当前火车进站，继续递归处理下一个火车（如果index序号合法）
    if (index < in.size()) {
        stk.push(in[index]);//index的火车进站
        // 处理下一辆火车
        dfs(in, index + 1, stk,path,res);// index+1的火车进站
        // 回溯
        stk.pop();
    }
    
    // 上一个火车出栈，继续递归处理当前火车（如果站中存在火车）
    if (!stk.empty()) {
        // 上一个火车出栈
        int ans=stk.top();
        stk.pop();
        path.push_back(ans);//加入答案
        // 递归处理当前火车
        dfs(in, index, stk,path,res);
        // 回溯
        stk.push(path.back());
        path.pop_back();
    }
}

int main(){
    // 获取输入
    int N;
    cin>>N;
    int tmp;
    vector<int> nums;
    while(N--){
        cin>>tmp;
        nums.push_back(tmp);
    }
    // 深度搜索
    stack<int> stk;
    vector<int> path;
    vector<vector<int>> res;
    dfs(nums, 0, stk,path,res);//nums个火车进出站的结果
    sort(res.begin(), res.end());//按照字典序进行排序
    // 输出结果
    for (auto p : res) {
        for (int a : p) { cout << a << " "; }
        cout << endl;
    }
    return 0;
}
```

## 6、**HJ90** **合法IP**

```C++
#include<iostream>
#include<arpa/inet.h>
using namespace std;

int main(){
     string s;
    while(getline(cin,s)){
        struct sockaddr_in sa;
        printf("%s\n",inet_pton(AF_INET, s.c_str(), &(sa.sin_addr))?"YES":"NO");
    }
    return 0;
}
```



# 七、模拟篇（3）

## 6、**HJ38** **求小球落地5次后所经历的路程和第5次反弹的高度**

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    double h;
    cin>>h;
    // 计算结果
    double dis=0;// 必须初始化，否则结果为nan
    for(int i=0;i<5;++i){
        dis+=h;//落地的长度
        h/=2; // 上升的长度
        if(i==4){
            printf("%.6f\n%.6f",dis,h);
        }
        dis+=h;// 加上弹上的长度
    }
    return 0;
}
```



# 八、链表篇（1）

## 5、**HJ48** **从单向链表中删除指定值的节点**

```C++
#include<iostream>
#include<algorithm>
#include<list>
using namespace std;

int main(){
    // 读取输入
    int n;
    int root;
    cin>>n>>root;
    // 创建lst
    list<int> lst;
    lst.push_back(root);
    int a,b;
    list<int>::iterator it;
    n--;
    while(n--){
        cin>>a>>b;//读取每组插入的数据
        it=find(lst.begin(),lst.end(),b);//查找b所在的索引
        it++;
        lst.insert(it,a);//在b索引之后添加a
    }
    int key;
    cin>>key;//读取要删除的节点值
    it=find(lst.begin(),lst.end(),key);//查找key所在的索引
    lst.erase(it);//删除key
    // 输出key
    for(auto it=lst.begin();it!=lst.end();++it){
        cout<<*it<<" ";
    }
    return 0;
}
```



# 九、栈篇（1）





