---

layout:     post
title:      「算法刷题」牛客华为题库（三）
subtitle:   C++11
date:       2022-04-15
author:     MRL Liu
header-img: img/post-bg-hacker.png
catalog: true
tags:
    - 算法刷题
---

[TOC]

​		华为机试题库共103道题目，其中入门级5道，简单级46道，中等级36道，较难级13道，困难级3道。计划在7天内共完成入门级，简单级，中等级的共计87道题目，则每天应当完成13道左右。计划每天完成：

​			入门级：1道    简单级：7道      中等级：6道        

# 一、入门级

## **HJ101** **输入整型数组和排序标识，对其元素按照升序或降序进行排序**

```c++
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
bool cmp(int a,int b){
    return a>b;
}

int main(){
    // 获取输入
    int n;
    cin>>n;
    int temp;
    vector<int> arr;
    while(n--){
        cin>>temp;
        arr.push_back(temp);
    }
    int k;
    cin>>k;
    // 返回结果
    if(k==0){
        sort(arr.begin(),arr.end());
    }
    else if(k==1){
        sort(arr.begin(),arr.end(),cmp);
    }
    // 输出结果
    for(int i=0;i<arr.size();++i){
         cout<<arr[i]<<" ";
    }
    return 0;
}
```

# 二、简单级

## 1、**HJ23** **删除字符串中出现次数最少的字符**

```c++
#include<iostream>
#include<string>
#include<unordered_map>
using namespace std;

int main(){
    // 获取输入
    string s;
    getline(cin,s);
    // 统计频率
    unordered_map<char, int> dict;
    for(char c:s){
        dict[c]++;
    }
    int min_q=20;
    for(auto it:dict){
        if(it.second<min_q) min_q=it.second;
    }
    // 从最后一个字符向前走
    int left=0;
    int right=0;
    int n=s.length();
    while(right<n){
        if(dict[s[right]]==min_q){
            right++;
        }
        else{
           s[left++]=s[right++]; 
        }
    }
    cout<<s.substr(0,left);
    return 0;
}
```

## 2、**HJ51** **输出单向链表中倒数第k个结点**

```C++
#include <iostream>
#include <string>
#include <algorithm>
using namespace std;

struct ListNode
{
    int m_nKey;
    ListNode* m_pNext;
    ListNode(int val){m_nKey=val;m_pNext=nullptr;}
};


int main(){
    // 获取输入
    int n;
    ListNode* myCode= new ListNode(0);
    while(cin>>n){
        int tmp=0;
        ListNode* p=myCode;// 非常重要，遍历指针法
        while(n--){
            cin>>tmp;
            //创建单链表
            ListNode* newCode= new ListNode(tmp);
            p->m_pNext=newCode;
            p=p->m_pNext;
        }
        // 获取k
        cin>>tmp;
        ListNode* left=myCode->m_pNext;
        ListNode* right=myCode->m_pNext;
        while(tmp--) {
            right=right->m_pNext;
        }
        while(right){
            left=left->m_pNext;
            right=right->m_pNext;
        }
        cout<<left->m_nKey<<endl;
    }
}
```

## 3、**HJ81** **字符串字符匹配**

```c++
#include <iostream>
#include <string>
#include <unordered_map>
using namespace std;

int main(){
    // 获取输入
    string s1;
    string s2;
    unordered_map<char,int> dict;
    while(getline(cin, s1)){
        getline(cin, s2);
        bool flag=true;
        for(char c:s2) dict[c]++;//统计长字符串中的所有字符频率
        // 遍历短字符串
        for(char c:s1){
            // 如果有一个字符在字典中不存在则结果为false
            if(dict.count(c)==0){
                flag=false;
                break;
            }
        }
        if(flag) cout<<"true"<<endl;
        else cout<<"false"<<endl;
    }
}
```

## 4、**HJ102** **字符统计**

```C++
#include <bits/stdc++.h>
using namespace std;

class mycomp{
public:
    bool operator()(const pair<char,int>& a,const pair<char,int>& b){
        if(a.second==b.second){
            return a.first>b.first;
        }
        else{
            return a.second<b.second;
        }
    }
};

int main(){
    // 获取输入
    string s;
    unordered_map<char,int> dict;
    priority_queue<pair<char,int>,vector<pair<char,int>>,mycomp> que;
    while(getline(cin, s)){
        for(char c:s) dict[c]++;//统计长字符串中的所有字符频率
        // 遍历短字符串
        for(auto p:dict){
            que.push(p);
        }
        // 输出
        while(!que.empty()){
            auto p=que.top();
            que.pop();
            cout<<p.first;
        }
        cout<<endl;
    }
}
```

## 5、**HJ94** **记票统计**

```c++
#include <bits/stdc++.h>
using namespace std;

int main(){
    // 获取n个候选人的输入
    int n;
    cin>>n;
    map<string,int> dict;// 字典，统计候选人票数
    vector<string> arr;// 数组，按照输入顺序保存，为了输出
    dict["Invalid"]=0;
    string tmp;
    while(n--){
       cin>>tmp;
       dict[tmp]=0;
       arr.push_back(tmp);
    }
    arr.push_back("Invalid");
    // 获取k个选票的输入
    int k;
    cin>>k;
    while(k--){
       cin>>tmp;
       if(dict.count(tmp))dict[tmp]++;// 有效选票
       else dict["Invalid"]++;// 无效选票
    }
    // 输出结果
    for(auto s:arr) cout<<s<<" : "<<dict[s]<<endl;
}
```

## 6、**HJ37** **统计每个月兔子的总数**

```C++
#include <bits/stdc++.h>
using namespace std;
/*斐波那契数列：1:1 2:1 3:2 4:3 5:5 6:8*/
int getSum(int n) { //求每个月兔子数
    if(n == 1 || n == 2) //n=1或2跳出递归
        return 1;
    return getSum(n - 1) + getSum(n - 2); //返回前两个月相加
}
int main(){
    // 获取输入
    int n;
    cin>>n;
    // 输出结果
    int res;
    res=getSum(n);
    cout<<res;
}
```

## 7、**HJ84** **统计大写字母个数**

```C++
#include <bits/stdc++.h>
using namespace std;

int main(){
    // 获取n个候选人的输入
    string s;
    getline(cin,s);
    // 输出大写字母的个数
    int res=0;
    for(char c:s){
        if(c>='A'&&c<='Z') res++;
    }
    cout<<res;
}
```

# 三、中等级

## 1、**HJ63** **DNA序列**

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    string s;
    getline(cin,s);
    int N;
    cin>>N;
    // 处理
    int len=s.length();
    string sub;
    string res;
    int maxgc=0;
    // 遍历字符串
    for(int i=0;i<=len-N;++i){
        sub=s.substr(i,N);//获取从索引i开始的N长度的子串
        int gc=0;
        // 统计该子串中GC个数
        for(char c:sub){
            if(c=='G'||c=='C')
                gc++;
        }
        // 如果是最大则记录
        if(gc>maxgc){
            res=sub;
            maxgc=gc;
        }
    }
    cout<<res;
    return 0;
}
```

## 2、**HJ57** **高精度整数加法**

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    string s1;
    string s2;
    getline(cin,s1);
    getline(cin,s2);
    // 处理
    int i=s1.length()-1;
    int j=s2.length()-1;
    string res;
    bool carry=false;
    int sum=0;
    // 同时遍历两个字符串
    while(i>=0&&j>=0){
        sum=0;
        int n1=s1[i--]-'0';
        int n2=s2[j--]-'0';
        sum=n1+n2;
        if(carry) sum++;
        res=to_string(sum%10)+res;
        if(sum>=10) carry=true;
        else carry=false;
    }
    while(i>=0){
        int sum=s1[i--]-'0';
        if(carry) sum++;
        res=to_string(sum%10)+res;
        if(sum>=10) carry=true;
        else carry=false;
    }
    while(j>=0){
        int sum=s2[j--]-'0';
        if(carry) sum++;
        res=to_string(sum%10)+res;
        if(sum>=10) carry=true;
        else carry=false;
    }
    if(carry) res="1"+res;
    cout<<res;
    return 0;
}
```

## 3、**HJ66** **配置文件恢复**

```C++
#include<bits/stdc++.h>
#include<sstream>
using namespace std;

int main(){
    string input;
    vector<pair<string, string>> instru = {{"reset",""},
                                           {"reset","board"},
                                           {"board","add"},
                                           {"board","delete"},
                                           {"reboot","backplane"},
                                           {"backplane","abort"}};    //存放每一对关键字
    vector<string> outInstru = {"reset what","board fault","where to add",
                               "no board at all","impossible","install first"};    //存放每条命令对应执行结果
    while(getline(cin, input)) {    //获取输入的一行字符串
        stringstream ss(input);    //通过stingstream和getline的组合实现对字符串按空格进行分割
        string key1,key2;
        getline(ss, key1, ' ');
        getline(ss, key2, ' ');
        int count=0;    //记录匹配的关键字个数
        string result;    //存放执行结果
        for(auto it=instru.begin();it!=instru.end();it++) {//对所有命令进行匹配
            int i1=it->first.find(key1);//i1记录key1在命令的前半部分第一次出现的下标
            int i2;    //i2记录key2在命令的后半部分第一次出现的下标
            if(key2!="") {    //如果key2不为空字符串，则获取key2在命令的后半部分第一次出现的下标
                i2=it->second.find(key2);
            }else if(key2==""&&it->second.empty()) {    //如果key2和命令的后半部分都为空字符串，则i2为0
                i2=0;
            }else{    //否则i2为-1，表示后半部分没有匹配到对应的命令
                i2=-1;
            }
            if(i1==0 && i2==0) {    //只有当i1和i2都匹配成功时，才对匹配成功的命令进行计数
                count++;
                result = outInstru[it-instru.begin()];    //result存放执行结果
            }
        }
        if(count==1) {    //如果只有一个匹配的关键字，标志匹配命令成功，输出对应执行结果
            cout<<result<<endl;
        }else{    //否则就是没有匹配成功，输出"unknown command"
            cout<<"unknown command"<<endl;
        }
    }
    return 0;
}
```

## 4、**HJ74** **参数解析**

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    string s;
    getline(cin,s);
    // 遍历字符串，如果存在""，则将其中的空格改为*
    bool flag=false;
    for(int i=0;i<s.length();++i){
        // 如果此时遇到了左引号
        if(!flag&&s[i]=='"')flag=true;
        // 如果此时遇到了右引号
        else if(flag&&s[i]=='"')flag=false;
        //如果左引号已经遇到过
        if(flag&&s[i]==' ')s[i]='*';
    }
    // 转换为字符流，切分空格
    stringstream ss(s);
    string t;
    vector<string> arr;
    while(getline(ss,t,' ')){
        arr.push_back(t);
    }
    cout<<arr.size()<<endl;
    // 输出结果
    for(string t:arr){
        // 如果遇到了"，则将其中的*切换为空格
        if(t[0]=='"'){
            string res=t.substr(1,t.length()-2);
            for(char c:res){
                if(c=='*') cout<<' ';
                else cout<<c;
            }
            cout<<endl;
        } 
        else cout<<t<<endl;
    }
    return 0;
}
```

## 5、**HJ71** **字符串通配符**

```C++
#include<bits/stdc++.h>
using namespace std;
// 递归调用：匹配当前一个字符s是被匹配的，p是匹配的
bool match(const char* s,const char* p)
{
    // 终止条件
    if((*p=='\0')&&(*s=='\0'))return true;// 如果两个同时到达末尾，则匹配
    if((*p=='\0')||(*s=='\0'))return false;// 如果两个只有一个达到末尾，则不匹配
    // 如果当前字符是？
    if(*p=='?')
    {
        if(!isdigit(*s)&&!isalpha(*s)) return false;// 如果s不是英文字母和数字，则不匹配
        return match(s+1,p+1);// 匹配下一个字符
    }
    // 如果当前字符是*
    else if(*p=='*')
    {
        while(*p=='*')p++;//检查p后面是否存在*,如果存在继续右移
        p--;//p左移，此时p指向连续*中的最后一个*
        //匹配0个，匹配1个，匹配多个/-1个，直至1个
        return match(s,p+1) || match(s+1,p+1) || match(s+1,p);
    }
    // 如果当前字符的大小写匹配，则继续匹配下一个字符
    else if(tolower(*p)==tolower(*s))
        return match(s+1,p+1);// 匹配下一个字符
    return false;
}

int main(){ 
    string p,s;
    while(cin>>p>>s){
        bool res = match(s.c_str(),p.c_str());
        if(res)cout<<"true"<<endl;
        else cout<<"false"<<endl;
    }
    return 0;
}
```

## 6、**HJ38** **求小球落地5次后所经历的路程和第5次反弹的高度**

```C++
#include<bits/stdc++.h>
using namespace std;

int main(){
    // 获取输入
    double h;
    cin>>h;
    // 计算结果
    double dis=0;// 必须初始化，否则结果为nan
    for(int i=0;i<5;++i){
        dis+=h;//落地的长度
        h/=2; // 上升的长度
        if(i==4){
            printf("%.6f\n%.6f",dis,h);
        }
        dis+=h;// 加上弹上的长度
    }
    return 0;
}
```



